/*
 * @Author: Chacha
 * @Date: 2022-03-26 16:18:26
 * @Last Modified by: Chacha
 * @Last Modified time: 2022-03-26 16:25:18
 */

/**
 * JS实现一个带并发限制的异步调度器Scheduler，保证同时运行的任务最多有两个。完善下面代码的Scheduler类，使以下程序能够正常输出：
 * class Scheduler {
 *   add(promiseCreator) { ... }
 *   // ...
 * }
 *
 * const timeout = time => {
 *   return new Promise(resolve => {
 *     setTimeout(resolve, time)
 *   }
 * })
 *
 * const scheduler = new Scheduler()
 *
 * const addTask = (time,order) => {
 *   scheduler.add(() => timeout(time).then(()=>console.log(order)))
 * }
 *
 * addTask(1000, '1')
 * addTask(500, '2')
 * addTask(300, '3')
 * addTask(400, '4')
 * // output: 2 3 1 4
 *
 * 整个的完整执行流程：
 * 起始1、2两个任务开始执行
 * 500ms时，2任务执行完毕，输出2，任务3开始执行
 * 800ms时，3任务执行完毕，输出3，任务4开始执行
 * 1000ms时，1任务执行完毕，输出1，此时只剩下4任务在执行
 * 1200ms时，4任务执行完毕，输出4
 *
 */

class Scheduler {
    constructor() {
        this.queue = []; // 任务列表
        this.capacity = 2; // 任务队列容量
        this.runCount = 0; // 运行任务计数器
    }

    add(promiseCreator) {
        // 小于等于2，直接执行
        this.queue.push(promiseCreator);
        this.runQueue();
    }

    runQueue() {
        // 队列中还有任务才会被执行
        if (this.queue.length && this.runCount < this.capacity) {
            // 执行先加入队列的函数
            const promiseCreator = this.queue.shift();
            // 开始执行任务 计数+1
            this.runCount += 1;

            promiseCreator().then(() => {
                // 任务执行完毕，计数-1
                this.runCount -= 1;
                this.runQueue();
            });
        }
    }
}

const timeout = (time) => {
    return new Promise((resolve) => {
        setTimeout(resolve, time);
    });
};

const scheduler = new Scheduler();

const addTask = (time, order) => {
    scheduler.add(() => timeout(time).then(() => console.log(order)));
};

addTask(1000, "1");
addTask(500, "2");
addTask(300, "3");
addTask(400, "4");

// 控制台输出 2 3 1 4
